/* =============================================== *
 *                                                 *
 * knight.bminor                                   *
 *                                                 *
 *                                                 *
 * =============================================== */

N: integer = 6; // tamaño del tablero
pasos: integer = 0; // contador de pasos recursivos

index: function integer (x: integer, y:integer) = {
	return x * N + y;
}

// Función auxiliar para imprimir el tablero
print_board: function void (board: array [] integer) = {
	x: integer;
	
	for(x = 0; x < N; x++) {
		if (N == 4) {
			print board[index(x,0)], " ", board[index(x,1)], " ", board[index(x,2)], " ", board[index(x,3)], "\n";
		} else if (N == 5) {
			print board[index(x,0)], " ", board[index(x,1)], " ", board[index(x,2)], " ", board[index(x,3)], " ", board[index(x,4)], "\n";
		} else if (N == 6) {
			print board[index(x,0)], " ", board[index(x,1)], " ", board[index(x,2)], " ", board[index(x,3)], " ", board[index(x,4)], " ", board[index(x,5)], "\n";
		} else if (N == 7) {
			print board[index(x,0)], " ", board[index(x,1)], " ", board[index(x,2)], " ", board[index(x,3)], " ", board[index(x,4)], " ", board[index(x,5)], " ", board[index(x,6)], "\n";
		} else if (N == 8) {
			print board[index(x,0)], " ", board[index(x,1)], " ", board[index(x,2)], " ", board[index(x,3)], " ", board[index(x,4)], " ", board[index(x,5)], " ", board[index(x,6)], " ", board[index(x,7)], "\n";
		}
	}
}

// funcion auxiliar para validar si un movto es valido
can_move: function boolean (x:integer, y:integer, board: array [] integer) = {
	if (x >= 0 && x < N && y >= 0 && y < N) {
		return board[index(x,y)] == 0;
	}
	return false;
}

// Funcion recursiva para recorrer el caballo el tablero
walk: function boolean (x: integer, y: integer, m: integer, board: array [] integer, xmoves: array [] integer, ymoves: array [] integer) = {
	i: integer;
	
	// Incrementar contador de pasos
	pasos = pasos + 1;
	
	if (m == N * N) {
		print_board(board);
		return true;
	}
	
	for (i = 0; i < array_length(xmoves); i++) {
		next_x: integer = x + xmoves[i];
		next_y: integer = y + ymoves[i];
		if (can_move(next_x, next_y, board)) {
			board[index(next_x, next_y)] = m;
			if (walk(next_x, next_y, m+1, board, xmoves, ymoves)) {
				return true;
			}
			board[index(next_x, next_y)] = 0;
		}
	}
	return false;
}


main: function void () = {
	board: array [N*N] integer;
	i: integer;
	
	// Inicializar el tablero a 0
	for (i = 0; i < N * N; i++) {
		board[i] = 0;
	}
	
	// Orden optimizado de movimientos del caballo
	// Este orden suele funcionar mejor para encontrar soluciones
	xmoves: array [8] integer = {1, 2, 2, 1, -1, -2, -2, -1};
	ymoves: array [8] integer = {2, 1, -1, -2, -2, -1, 1, 2};
	
	// Marcar la posicion inicial
	board[index(0, 0)] = 1;
	
	if (walk(0, 0, 2, board, xmoves, ymoves)) {
		print "Tour completo encontrado:\n";
		print "Total de pasos (llamadas recursivas): ", pasos, "\n";
	} else {
		print "No existe solucion!\n";
		print "Total de pasos intentados: ", pasos, "\n";
	}

}
